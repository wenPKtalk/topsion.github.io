---
title: 数据库事务的来龙去脉2-分布式事务的演进
date: 2022-07-08 09:12:43
tags: [Transcation,Database]
categories: [Database]
---

> 本地事务相对比较简单，很容易实现。但是上升到全局事务再到分布式事务就比较麻烦，对保证数据一致性就需要做很多额外的处理。

### 从全局事务（Global Transactions）谈起

全局事务即外部事务（External Transaction）：一种适用于单个服务使用多个数据源场景的事务解决方案。

实际上DTP（Distributed Transaction Processing）中没有上边这种限定。本篇分为两大类：

1. 在分布式（单服务多个数据源）环境中追求强一致性。
2. 在分布式（微服务）中放弃ACID追求弱一致性。

#### XA（Extended Architecture）协议

定义了**全局事务管理器（Transaction Manager）：用于协调全局事务**和**局部的资源管理器（Resources Manager）：用于驱动本地事务**之间的通讯接口。

XA接口是双向的，一个事务管理器和多个资源管理器之间通信的桥梁，协调多个数据源保持一致，来实现全局事务的统一提交或者统一回滚。XADataSource XAResource。**XA并不是java规范，是一套通用技术。 Java后来专门定义了一套全局事务处理标准JTA**

#### JTA（Java Transaction API）

Java定义的一套全局事务处理标准。

* 事务管理器接口： javax.transaction.TransactionManager，这套接口是给Java EE服务提供容器事务（由容器自动负责事务管理）使用。javax.transaction.UserTransaction接口，给程序员使用用于通过程序代码手动开启，提交和回滚事务。
* 满足XA规范的资源定义接口：javax.transaction.xa.XAResource。任何资源（JDBC，JMS等）如果需要支持JTA，只要实现XAResource接口中的方法即可。

> JTA 原本是 Java EE 中的技术，一般情况下应该由 JBoss、WebSphere、WebLogic 这些 Java EE 容器来提供支持，但现在Bittronix、Atomikos和JBossTM（以前叫 Arjuna）都以 JAR 包的形式实现了 JTA 的接口，也就是 JOTM（Java Open Transaction Manager）。有了 JOTM 的支持，我们就可以在 Tomcat、Jetty 这样的 Java SE 环境下使用 JTA 了。

#### 两阶段提交（2 Phase Commit 2PC）

```java

public void buyBook(PaymentBill bill) {
  userTransaction.begin();
    warehouseTransaction.begin();
    businessTransaction.begin();
  try {
      userAccountService.pay(bill.getMoney());
      warehouseService.deliver(bill.getItems());
      businessAccountService.receipt(bill.getMoney());
        userTransaction.commit();
      warehouseTransaction.commit();
      businessTransaction.commit();
  } catch(Exception e) {
        userTransaction.rollback();
      warehouseTransaction.rollback();
      businessTransaction.rollback();
  }
}
```

如上开启了三个事务，业务处理完成后做了三次事务提交。但是如果三个commit中第二个和第三个commit出现了Exception那么已经提交的事务rollback不了，这样就破坏了全局事务的一致性。为了解决这种问题提出了两阶段提交。

* **准备阶段**：投票阶段，协调者询问所有事务参与者是否已经准备好，准备好：Prepared 否则：Non-Prepared。对于数据库来讲，准备操作是是在重做日志中记录全部事务提交操作所要做的内容，与本地事务主要区别是：暂时不写入最后一条Commit Record。这意味着做完数据持久化后暂时不会释放隔离性，也就是依然持有锁。
* **提交阶段**：协调者受到所有事务参与者恢复的Prepared消息，就会首先在本地持久化事务状态未Commit，然后向所有参与者发送Commit指令。否则任意一个参与者回复Non-Prepared消息，协调者都会将自己事务状态持久化未Abort并且发送给所有参与者。

因为提交阶段相对轻量级，仅仅是持久化一条指令 Commit Record能够快速完成。回滚阶段则相对耗时，收到Abort时需要根据Undo log清理已经提交的数据。

**缺点：**

* **单点问题：**协调者单点
* **性能问题：** 两阶段提交过程中，所有参与者

