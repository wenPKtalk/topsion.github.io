---
title: 深入理解JVM-Jvm垃圾回收二三事
date: 2022-09-01 08:20:45
tags: [JVM, GC]
categories: JVM
---

> 众所周知Java作为高级编程语言是不需要程序员去手动释放内存垃圾（**垃圾指的是死亡的对象所占据的堆空间**），JVM会替我们完成。那么JVM是如何识别出来哪些是需要被回收的对象？JVM是如何整理内存空间？JVM GC(Garbage Collection)过程和应用程序的线程有哪些相互影响？

### 如何识别垃圾对象？

> 程序员不需要手动编码精准释放不用的对象，那么JVM是如何做到自动识别的呢？

- #### 引用计数法（reference counting）

  做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦一个对象的引用计数器为0，则说明该对象已经死亡，它所占用的堆空间可以被回收。

  **优点：**

  ​	算法简单，容易实现：如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器 +1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器 -1。也就是说，我们需要截获所有的引用更新操作，并且相应地增减目标对象的引用计数器。

  **缺点：**

   1. 需要额外的空间存储计数器，和繁琐的计数器更新。

   2. 无法解决循环引用造成内存泄漏。

      <img src="https://cdn.jsdelivr.net/gh/wenPKtalk/pictures@master/blog/20220525/09_36/8546a9b3c6660a31ae24bef0ef0a35b9.png" alt="img" style="zoom: 33%;" />

      > 对象 a 与 b 相互引用，除此之外没有其他引用指向 a 或者 b。在这种情况下，a 和 b 实际上已经死了，但由于它们的引用计数器皆不为 0，在引用计数法的心中，这两个对象还活着。因此，这些循环引用对象所占据的空间将不可回收，从而造成了内存泄露。

  - #### 可达性分析（JVM采用）

    将一系列GC Roots作为初始的存活对象合集（Live Set），然后从该集合出发，探索所有能被该集合引用到的对象，将其加入该集合中，这一过程也被称作标记（Mark）。最终未被探索到的对象便是死亡的，是可以回收的。

    **GC Roots可以理解为由堆外指向堆内的引用，一般包括但不仅限于以下：**

    1. Java方法栈中的布局变量。[Java内存布局]([https://wenpktalk.github.io/2020/05/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/])
    2. 已加载类的静态变量。
    3. 本地方法栈中Native方法引用的对象
    4. 虚拟机栈（栈帧中本地变量表）中引用的对象
    5. 已经启动且未停职的线程。

   
