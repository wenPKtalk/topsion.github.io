---
title: 深入理解JVM-Jvm垃圾回收二三事
date: 2022-09-01 08:20:45
tags: [JVM, GC]
categories: JVM
---

> 众所周知Java作为高级编程语言是不需要程序员去手动释放内存垃圾（**垃圾指的是死亡的对象所占据的堆空间**），JVM会替我们完成。那么JVM是如何识别出来哪些是需要被回收的对象？JVM是如何整理内存空间？JVM GC(Garbage Collection)过程和应用程序的线程有哪些相互影响？

### 如何识别垃圾对象-识别算法

> 程序员不需要手动编码精准释放不用的对象，那么JVM是如何做到自动识别的呢？

- #### 引用计数法（reference counting）

  做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦一个对象的引用计数器为0，则说明该对象已经死亡，它所占用的堆空间可以被回收。

  **使用此类算法的有 Python、Objective-C、Per l等。**

  **优点：**

  ​	算法简单，容易实现：如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器 +1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器 -1。也就是说，我们需要截获所有的引用更新操作，并且相应地增减目标对象的引用计数器。

  **缺点：**

   1. 需要额外的空间存储计数器，和繁琐的计数器更新。

   2. 无法解决循环引用造成内存泄漏。

      <img src="https://cdn.jsdelivr.net/gh/wenPKtalk/pictures@master/blog/20220525/09_36/8546a9b3c6660a31ae24bef0ef0a35b9.png" alt="img" style="zoom: 33%;" />

      > 对象 a 与 b 相互引用，除此之外没有其他引用指向 a 或者 b。在这种情况下，a 和 b 实际上已经死了，但由于它们的引用计数器皆不为 0，在引用计数法的心中，这两个对象还活着。因此，这些循环引用对象所占据的空间将不可回收，从而造成了内存泄露。

  - #### 可达性分析（JVM采用）

    将一系列GC Roots作为初始的存活对象合集（Live Set），然后从该集合出发，探索所有能被该集合引用到的对象，将其加入该集合中，这一过程也被称作标记（Mark）。最终未被探索到的对象便是死亡的，是可以回收的。

    **GC Roots可以理解为由堆外指向堆内的引用，一般包括但不仅限于以下：**
  
    1. Java方法栈中的布局变量。[Java内存布局]([https://wenpktalk.github.io/2020/05/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/])
    2. 已加载类的静态变量。
    3. 本地方法栈中Native方法引用的对象
    4. 虚拟机栈（栈帧中本地变量表）中引用的对象
    5. 已经启动且未停职的线程。

### 回收算法-垃圾回收器的工作原理

由上一步的识别算法找到需要被回收的对象后，接下来就是需要将识别出来的垃圾对象所占用的内存空间进行回收，以便于进行再次利用。回收的算法主要包括：

基础算法：

1. 标记-清除算法
2. 标记-压缩算法
3. 标记-复制算法

改进算法（由上边的算法演进而来）：

4. 分代算法
5. 增量算法
6. 并发算法

#### 标记-清除（Sweep）

把死亡对象所占据的内存标记为空闲内存，并记录在一个**空闲列表（Free List）**中。当需要新建对象时，内存管理便会从空闲列表中寻找空闲内存，并划分给新建对象。

<img src="https://static001.geekbang.org/resource/image/f2/03/f225126be24826658ca5a899fcff5003.png" alt="img" style="zoom: 33%;" />

##### 优点：

原理，实现比较简单

##### 缺点

1. 造成内存碎片，由于Java虚拟机的堆中对象必须是连续分布，因此可能出现空闲内存足够，但是无法分配的极端情况。
2. 分配效率极低，如果是连续的内存空间我们可以通过指针加法（Pointer bumping）来做分配。而对于空闲列表，java虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。

#### 标记-压缩（Compact）

把存活的对象挪到内存的起始位置。

<img src="https://static001.geekbang.org/resource/image/41/39/415ee8e4aef12ff076b42e41660dad39.png" alt="img" style="zoom:33%;" />

##### 优点

这样做能够开辟出连续的空间，解决内存碎片化问题。

#### 缺点

压缩算法的性能开销比较大。

#### 标记-复制（Copy）

把内存区域划分为两份，分别使用**from**和**to**来维护，并且只是用from指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活对象复制到to指针指向的内存区域中，并且交换from指针和to指针指向的内容。

<img src="https://static001.geekbang.org/resource/image/47/61/4749cad235deb1542d4ca3b232ebf261.png" alt="img" style="zoom:33%;" />

##### 优点：

* 不会发生碎片化
* 优秀的吞吐率
* 可实现高速分配
* 良好的locality

##### 缺点：

由于to指针指向的区域始终是空闲的，所以空间利用率极低。

#### 分代算法（Generation）

分代算法基于这样一种假说（Generational Hypothesis）：**绝大多数对象都是朝生夕死的。**分代算法把对象分为几代，新生成的对象称之为：新生代，负责对新生代进行垃圾回收的叫minor GC。到达一定年龄的对象则称之为老年代对象，面向老年代GC的叫major GC。新生代到老年代的过程称之为：晋升（Promotion）注：代数并不是划分的越多越好，虽然按照分代假说，如果分代数越多，最后抵达老年代的对象就越少，在老年代对象上消耗的垃圾回收的时间就越少，但分代数增多会带来其他的开销，综合来看，代数划分为 2 代或者 3 代是最好的。

分代算法由于其普适性，已经被大多数的垃圾回收器采用（ZGC 目前不支持，但也在规划中了）。

#### 增量算法（Increment）

增量算法对基础算法的改进主要体现在该算法通过并发的方式，降低了 STW 的时间。下图是增量算法和基础的标记-清除算法在执行时间线上的对比，可以看到，增量算法的核心思想是：通过 GC 和应用程序交替执行的方式，来控制应用程序的最大暂停时间。

<img src="https://ucc.alicdn.com/pic/developer-ecology/41cebbc1c50e499db9926d45d4fca7d0.png" alt="image.png" style="zoom:33%;" />

增量算法的「增量」部分，主要有「增量更新（Incremental Update）」和「增量拷贝（Incremental Copying）」两种，前者主要是做「标记」增量，后者是在做「复制」增量。

#### 并发算法（Concurrent）

广义上的并发算法指的是在 GC 过程中存在并发阶段的算法，如 G1 中存在并发标记阶段，可将其整个算法视为并发算法。

狭义上的并发垃圾回收算法是以基础的标记-复制算法为基础，在各个阶段增加了并发操作实现的。与复制算法的3个阶段相对应，分为并发标记（mark）、并发转移（relocate）和并发重定位（remap）:

1）并发标记

从 GC Roots 出发，使用遍历算法对对象的成员变量进行标记。同样的，并发标记也需要解决标记过程中引用关系变化导致的漏标记问题，这一点通过写屏障实现；

（2）并发转移

根据并发标记后的结果生成转移集合，把活跃对象转移（复制）到新的内存上，原来的内存空间可以回收，转移过程中会涉及到应用线程访问待转移对象的情况，一般的解决思路是加上读屏障，在完成转移任务后，再访问对象；

（3）并发重定位

对象转移后其内存地址发生了变化，所有指向对象老地址的指针都要修正到新的地址上，这一步一般通过读屏障来实现。

### JVM堆空间划分



### 参考链接

[垃圾回收算法是如何设计的？](https://developer.aliyun.com/article/777750?source=5176.11533457&userCode=e4nptrfl)

