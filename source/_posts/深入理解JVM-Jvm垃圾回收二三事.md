---
title: 深入理解JVM-Jvm垃圾回收二三事
date: 2022-09-01 08:20:45
tags: [JVM, GC]
categories: JVM
---

> 众所周知Java作为高级编程语言是不需要程序员去手动释放内存垃圾（**垃圾指的是死亡的对象所占据的堆空间**），JVM会替我们完成。那么JVM是如何识别出来哪些是需要被回收的对象？JVM是如何整理内存空间？JVM GC(Garbage Collection)过程和应用程序的线程有哪些相互影响？

### 如何识别垃圾对象-识别算法

> 程序员不需要手动编码精准释放不用的对象，那么JVM是如何做到自动识别的呢？

- #### 引用计数法（reference counting）

  做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦一个对象的引用计数器为0，则说明该对象已经死亡，它所占用的堆空间可以被回收。

  **使用此类算法的有 Python、Objective-C、Per l等。**

  **优点：**

  ​	算法简单，容易实现：如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器 +1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器 -1。也就是说，我们需要截获所有的引用更新操作，并且相应地增减目标对象的引用计数器。

  **缺点：**

   1. 需要额外的空间存储计数器，和繁琐的计数器更新。

   2. 无法解决循环引用造成内存泄漏。

      <img src="https://cdn.jsdelivr.net/gh/wenPKtalk/pictures@master/blog/20220525/09_36/8546a9b3c6660a31ae24bef0ef0a35b9.png" alt="img" style="zoom: 33%;" />

      > 对象 a 与 b 相互引用，除此之外没有其他引用指向 a 或者 b。在这种情况下，a 和 b 实际上已经死了，但由于它们的引用计数器皆不为 0，在引用计数法的心中，这两个对象还活着。因此，这些循环引用对象所占据的空间将不可回收，从而造成了内存泄露。

  - #### 可达性分析（JVM采用）

    将一系列GC Roots作为初始的存活对象合集（Live Set），然后从该集合出发，探索所有能被该集合引用到的对象，将其加入该集合中，这一过程也被称作标记（Mark）。最终未被探索到的对象便是死亡的，是可以回收的。

    **GC Roots可以理解为由堆外指向堆内的引用，一般包括但不仅限于以下：**
  
    1. Java方法栈中的布局变量。[Java内存布局]([https://wenpktalk.github.io/2020/05/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/])
    2. 已加载类的静态变量。
    3. 本地方法栈中Native方法引用的对象
    4. 虚拟机栈（栈帧中本地变量表）中引用的对象
    5. 已经启动且未停职的线程。

### 回收算法-垃圾回收器的工作原理

由上一步的识别算法找到需要被回收的对象后，接下来就是需要将识别出来的垃圾对象所占用的内存空间进行回收，以便于进行再次利用。回收的算法主要包括：

基础算法：

1. 标记-清除算法
2. 标记-压缩算法
3. 标记-复制算法

改进算法（由上边的算法演进而来）：

4. 分代算法
5. 增量算法
6. 并发算法

#### 标记-清除（Sweep）

把死亡对象所占据的内存标记为空闲内存，并记录在一个**空闲列表（Free List）**中。当需要新建对象时，内存管理便会从空闲列表中寻找空闲内存，并划分给新建对象。

<img src="https://static001.geekbang.org/resource/image/f2/03/f225126be24826658ca5a899fcff5003.png" alt="img" style="zoom: 33%;" />

##### 优点：

原理，实现比较简单

##### 缺点

1. 造成内存碎片，由于Java虚拟机的堆中对象必须是连续分布，因此可能出现空闲内存足够，但是无法分配的极端情况。
2. 分配效率极低，如果是连续的内存空间我们可以通过指针加法（Pointer bumping）来做分配。而对于空闲列表，java虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。

#### 标记-压缩（Compact）





### 参考链接

[垃圾回收算法是如何设计的？](https://developer.aliyun.com/article/777750?source=5176.11533457&userCode=e4nptrfl)

