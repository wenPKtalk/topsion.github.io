---
title: 篇章1-MySql架构基础及执行引擎
date: 2018-11-25 16:35:40
tags: [Database, Mysql]
categories: [Mysql]
---

### MySQL的架构示意：

![img](https://cdn.jsdelivr.net/gh/wenPKtalk/pictures@master/blog/20220412/16_39/0d2070e8f84c4801adbfa03bda1f98d9.png)

> MySQL大体分为两层：Server 层和存储引擎层
> > 1. server层: 连接器，查询缓存，分析器，优化器等，涵盖MySQL的大多数核心服务功能，一级所有内置函数（如日期，时间，数学和加密函数等），所有夸存储引起的功能都在这一层实现，比如：存过，触发器，视图等。
> > 2. 存储引擎负责数据的存储和提取：innoDB,MyISAM,Memory等 MySql5.5.5版本开始默认为InnoDB

### 个层次分工：

1. 连接器：顾名思义连接器负责跟客户端建立连接、获取权限、维持和管理连接
你可以在 show processlist 命令中看到它。Command列显示为Sleep则表示该连接为空闲链接。  
2. 查询缓存：连接建立完成后，你就可以执行 select 语句了。执行逻辑第二步查询缓存。  
优势：提高查询效率，适合表数据不经常做更新的。  
劣势：一张表有更新机会清空缓存，命中率会很低。  
使用参数 query_cache_type 设置成 DEMAND这样对应默认的SQL语句是不适用查询缓存的，显示指定的时候才会查询缓存如下：
```sql
select SQL_CACHE * FROM T WHERE ID = 10;
```
3. 分析器：如果没有命中缓存则开始对SQL语句进行解析，生成解析树。
4. 经过了分析器，MySQL 就知道你要做什么了。在开始执行之前得经过优化器的处理，包括表里有多个索引时决定使用哪个索引；一个语句有多表关联的时候决定各个表的连接顺序；
比如：
> mysql> select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;  
> 1. 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于20。
> 2. 也可以先从表 t2 里面取出 d=20 的记录的 ID 值,再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是是否等于 10。

*后边仔细分析对索引的选择*
5. 执行器：MySql通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了之情器阶段开始执行语句。  
如以下语句的执行过程：
```
mysql> select * from T where ID=10;

```
执行器会根据表定义的引擎取调用这个引擎所提供的接口。比如我们例句中提供的表T，ID无索引则会：  
> 1. 调用InnoDB引擎接口取这个表的第一行，判断ID是否为10，如果不是则跳过，如果是则将这行存在结果集中；
> 2.调用引擎接口取“下一行”，重复相同的判断逻辑，指导取到这个表的最后一行。
> 3.执行器将上述遍历过程中所有满足的条件行组成记录集作为结果返回给客户端。

至此这个语句执行就完成了。
对于有索引的表，执行的逻辑也差不多。第一次调用的是**“满足条件得第一行“这个接口，之后循环取“满足条件的下一行”这个接口。** 这些接口都是存储殷勤中定义好的。  
** rows_examined **：表示语句扫描了多少行，这个值就是执行器每次调用引擎获取数据行时累加的。  
**在某些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟rows_examined（调用次数可能小于扫描行数）并不是完全相同的**

>阅读《MySQL实战45讲》
